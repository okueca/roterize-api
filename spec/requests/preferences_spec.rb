require 'rails_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to test the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator. If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails. There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.

RSpec.describe "/preferences", type: :request do
  # This should return the minimal set of attributes required to create a valid
  # Preference. As you add validations to Preference, be sure to
  # adjust the attributes here as well.
  let!(:user) { User.create!(email: "user_p#{SecureRandom.hex(4)}@test.com", password: 'secret123', password_confirmation: 'secret123', name: 'Tester')}

  let(:valid_attributes) {
        {
          "reason": "encontro",
          "location": "Lisboa",
          "when": "hoje",
          "badget": "200 euros",
          "activities_preference": ["natureza", "comida", "museus"],
          "final_reason": "quero que ela se sinta especial",
          "time_range_start": "10:00",
          "time_range_end": "20:00",
          "personality_type": "introvertida",
          "mobility": "public_transport",
          "weather_tolerance": "sunny",
          "romantic_level": 2,
          "group_size": 4,
          "custom_notes": "5 anos arranjando coragem",
          "user_id": user.id
        }
  }

  let(:invalid_attributes) {
        {
          "reason": "encontro",
          "location": "Lisboa",
          "when": "hoje",
          "badget": "200 euros",
          "activities_preference": ["natureza", "comida", "museus"],
          "final_reason": "quero que ela se sinta especial",
          "time_range_start": "10:00",
          "time_range_end": "20:00",
          "personality_type": "introvertida",
          "mobility": "public_transport",
          "weather_tolerance": "sunny",
          "romantic_level": 2,
          "group_size": 4,
          "custom_notes": "5 anos arranjando coragem",
          "user_id": "invalidID"
        }
  }

  # This should return the minimal set of values that should be in the headers
  # in order to pass any filters (e.g. authentication) defined in
  # PreferencesController, or in your router and rack
  # middleware. Be sure to keep this updated too.
  let(:valid_headers) {
    {'Content-Type' => 'application/json'}
  }

  describe "GET /index" do
    it "renders a successful response" do
      Preference.create! valid_attributes
      get preferences_url, headers: valid_headers, as: :json
      expect(response).to be_successful
    end
  end

  describe "GET /show" do
    it "renders a successful response" do
      preference = Preference.create! valid_attributes
      get preference_url(preference), as: :json
      expect(response).to be_successful
    end
  end

  describe "POST /create" do
    context "with valid parameters" do
      it "creates a new Preference" do
        expect {
          post preferences_url,
               params: { preference: valid_attributes }.to_json , headers: valid_headers
        }.to change(Preference, :count).by(1)
      end

      it "renders a JSON response with the new preference" do
        post preferences_url,
             params: { preference: valid_attributes }.to_json, headers: valid_headers
        expect(response).to have_http_status(:created)
        expect(response.content_type).to match(a_string_including("application/json"))
      end
    end

    context "with invalid parameters" do
      it "does not create a new Preference" do
        expect {
          post preferences_url,
               params: { preference: invalid_attributes }.to_json
        }.to change(Preference, :count).by(0)
      end

      it "renders a JSON response with errors for the new preference" do
        post preferences_url,
             params: { preference: invalid_attributes }.to_json, headers: valid_headers
        expect(response).to have_http_status(:unprocessable_content)
        expect(response.content_type).to match(a_string_including("application/json"))
      end
    end
  end

  describe "PATCH /update" do
    context "with valid parameters" do
      let(:new_attributes) {
        {
          "reason": "jantar de amigos",
          "location": "Lisboa",
          "when": "hoje",
          "badget": "300 euros"
        }
      }

      it "updates the requested preference" do
        preference = Preference.create! valid_attributes
        patch preference_url(preference),
              params: { preference: new_attributes }.to_json, headers: valid_headers
        preference.reload
        # expect(preference.badget).to "300 euros"
        expect(response).to have_http_status(:ok)
      end

      it "renders a JSON response with the preference" do
        preference = Preference.create! valid_attributes
        patch preference_url(preference),
              params: { preference: new_attributes }.to_json, headers: valid_headers
        expect(response).to have_http_status(:ok)
        expect(response.content_type).to match(a_string_including("application/json"))
      end
    end

    context "with invalid parameters" do
      it "renders a JSON response with errors for the preference" do
        preference = Preference.create! valid_attributes
        patch preference_url(preference),
              params: { preference: invalid_attributes }.to_json, headers: valid_headers
        expect(response).to have_http_status(:unprocessable_content)
        expect(response.content_type).to match(a_string_including("application/json"))
      end
    end
  end

  describe "DELETE /destroy" do
    it "destroys the requested preference" do
      preference = Preference.create! valid_attributes
      expect {
        delete preference_url(preference), headers: valid_headers, as: :json
      }.to change(Preference, :count).by(-1)
    end
  end
end
